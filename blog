#!/usr/bin/env python

## Imports

import os
import io
import re
import sys
import glob
import json
import shutil
import hashlib
import subprocess
from pathlib import Path
from datetime import datetime, timedelta
from functools import partial, lru_cache
from typing import Dict, Tuple, List, Callable
from argparse import ArgumentParser, Namespace

from jinja2 import Template, Environment, FileSystemLoader


## Constants

HTMLDIR: Path = Path("html")
TAGDIR: Path = Path("tags")
POSTDIR: Path = Path("posts")
STATICDIR: Path = Path("static")
TEMPLATEDIR: Path = Path("templates")
COMMANDS: Tuple[str, ...] = ("build", "clean", "init")

## Decorators
cache = partial(lru_cache, None, True)

## Functions

def symbolic_link(src: Path, dest: Path):
    subprocess.check_output(["ln", "-srf", src, dest])

def get_template(name: str):
    path = TEMPLATEDIR/name
    if not os.path.exists(path):
        return Template("")
    with open(path, "r") as file:
        content = file.read()
    return Environment(loader=FileSystemLoader(TEMPLATEDIR)).from_string(content)

def md2html(content: str) -> str:
    # TODO: do this more robustly:
    parts = content.split("](")
    for i, part in enumerate(parts[1:], start=1):
        smallparts = part.split(")")
        if not smallparts[0].endswith(".md"):
            continue
        smallparts[0] = f"{Path(smallparts[0]).stem}.html"
        parts[i] = ")".join(smallparts)
    content = "](".join(parts)
    mdout = subprocess.Popen(["printf", content], stdout=subprocess.PIPE).stdout
    html = subprocess.check_output(['pandoc'], stdin=mdout).decode().strip()
    return html

def ipynb2html(content: str) -> str:
    from nbconvert.nbconvertapp import NbConvertApp
    from nbconvert.exporters.html import HTMLExporter
    app = NbConvertApp.instance()
    app.initialize(["--template=basic"])
    app.exporter = HTMLExporter(config=app.config)
    html, _ = app.export_single_notebook(
        notebook_filename=None,
        resources=None,
        input_buffer=io.StringIO(content)
    )
    return html


## Classes

class Post:
    _posts: Dict[Path, 'Post'] = {}
    _template = get_template("post.html")
    def __new__(cls, path: Path):
        if path in cls._posts:
            return cls._posts[path]
        return super().__new__(cls)
    def __init__(self, path: Path):
        if path in self._posts:
            return
        self.path = Path(path)
        self.tags: List[Tag] = []
        self._posts[path] = self
        self.lines = self.readlines()
    def readlines(self):
        with open(self.path, "r") as file:
            lines = file.read().split("\n")
        return lines
    def render(self):
        html = self._template.render(page=self)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    @cache()
    def author(self) -> str:
        author = subprocess.check_output(['git', 'log', '--pretty=format:%an%x09', self.path]).decode().split("\n")[0].strip()
        if not author:
            author = "Anonymous"
        return author.lower().capitalize()
    @cache()
    def content(self) -> str:
        return md2html("\n".join(self.lines[1:]))
    @cache()
    def id(self) -> str:
        m = hashlib.md5()
        m.update(self.summary().encode())
        return m.hexdigest()[:7]
    @cache()
    def name(self) -> str:
        return str(self.path.relative_to(POSTDIR).stem)
    @cache()
    def uri(self) -> str:
        return f"{self.name()}.html"
    @cache()
    def uriprefix(self) -> str:
        return "./"
    @cache()
    def utcpublished(self) -> datetime:
        datetimestr = subprocess.check_output(['git', 'log', '--diff-filter=A', '--follow', '--format=%aD', '--max-count=1', '--', self.path]).decode().strip()
        localdatetime = datetime.strptime(datetimestr, "%a, %d %b %Y %H:%M:%S %z")
        utcoffset = localdatetime.tzinfo.utcoffset(localdatetime)
        return datetime.strptime((localdatetime-utcoffset).strftime("%Y%b%d%H%M%S"), "%Y%b%d%H%M%S")
    @cache()
    def utcmodified(self) -> datetime:
        datetimestr = subprocess.check_output(["git", "log", "-1", '--format="%aD"', "--", self.path]).decode().strip()
        localdatetime = datetime.strptime(datetimestr, "\"%a, %d %b %Y %H:%M:%S %z\"")
        utcoffset = localdatetime.tzinfo.utcoffset(localdatetime)
        return datetime.strptime((localdatetime-utcoffset).strftime("%Y%b%d%H%M%S"), "%Y%b%d%H%M%S")
    @cache()
    def summary(self) -> str:
        lines = []
        for line in self.lines[1:]:
            line = line.strip()
            if not line:
                break
            lines.append(line)
        html = md2html("\n".join(lines))
        return html
    @cache()
    def title(self) -> str:
        title = re.sub("^[ ]*[#]*[ ]*", "", self.lines[0])
        return title

class NotebookPost(Post):
    def __init__(self, path: Path):
        super().__init__(path)
        self.json = self.readjson()
        self.lines = self.readlines()

    def readjson(self):
        with open(self.path, "r") as file:
            dic = json.load(file)
        return dic

    def readlines(self):
        if not hasattr(self, "json"):
            return []
        with open(self.path, "r") as file:
            lines = "".join(self.json["cells"][0]["source"]).split("\n")
        return lines

    @cache()
    def content(self) -> str:
        return ipynb2html(json.dumps(self.json))

class MarkdownPost(NotebookPost):
    def readjson(self):
        with open(self.path, "r") as file:
            dic = {
                "cells": [
                    {
                       "cell_type": "markdown",
                       "metadata": {},
                        "source" : file.readlines(),
                    }
                ],
                 "metadata": {},
                 "nbformat": 4,
                 "nbformat_minor": 4
            }
        return dic


class Tag:
    _tags: Dict[Path, 'Tag'] = {}
    _template = get_template("tag.html")
    def __new__(cls, path: Path):
        if path in cls._tags:
            return cls._tags[path]
        return super().__new__(cls)
    def __init__(self, path: Path):
        if path in self._tags:
            return
        self.path = Path(path)
        self.posts: List[Post] = []
        self._tags[path] = self
        for post_path in self.path.glob("*"):
            post_path = post_path.resolve().relative_to(Path(".").resolve())
            if post_path.is_dir():
                continue
            elif post_path.suffix == ".md":
                post = MarkdownPost(post_path)
            elif post_path.suffix == ".ipynb":
                post = NotebookPost(post_path)
            else:
                continue
            self.posts.append(post)
            post.tags.append(self)
    def render(self):
        html = self._template.render(page=self)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    @cache()
    def name(self) -> str:
        return str(self.path.relative_to(TAGDIR).stem)
    @cache()
    def uri(self) -> str:
        return str(TAGDIR/f"{self.name()}.html")
    @cache()
    def uriprefix(self) -> str:
        return "../"
    @cache()
    def title(self) -> str:
        return self.name().capitalize()

class Index:
    _template = get_template("index.html")
    def __init__(self):
        self.posts, self.tags = [], []
        for post_path in POSTDIR.glob("*"):
            if post_path.is_dir():
                continue
            elif post_path.suffix == ".md":
                post = MarkdownPost(post_path)
            elif post_path.suffix == ".ipynb":
                post = NotebookPost(post_path)
            else:
                continue
            self.posts.append(MarkdownPost(post_path))
        for tag_path in TAGDIR.glob("*"):
            self.tags.append(Tag(tag_path))
    def render(self):
        html = self._template.render(page=self)
        for post in self.posts:
            post.render()
        for tag in self.tags:
            tag.render()
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    @cache()
    def name(self) -> str:
        return "index"
    @cache()
    def title(self) -> str:
        return self.name().capitalize()
    @cache()
    def uri(self) -> str:
        return f"{self.name()}.html"
    @cache()
    def uriprefix(self) -> str:
        return "./"


## Argument parser

def parse_args(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog: a static blog generator.")
    parser.add_argument("command", choices=COMMANDS, help="subcommand to execute")
    parsed_args = parser.parse_args(args)
    return parsed_args


## Commands

def command_build(args: Namespace):
    command_init(args)
    index = Index()
    index.render()

def command_clean(args: Namespace):
    for directory in (HTMLDIR, HTMLDIR/TAGDIR):
        shutil.rmtree(directory, ignore_errors=True)
    command_init(args)

def command_init(args: Namespace):
    for directory in (HTMLDIR, TAGDIR, POSTDIR, STATICDIR, TEMPLATEDIR, HTMLDIR/TAGDIR):
        os.makedirs(directory, exist_ok=True)
    symbolic_link(STATICDIR, HTMLDIR)
    symbolic_link(STATICDIR, POSTDIR)

## Main

def main(args: List[str]):
    if Path(".").absolute() != Path(__file__).parents[0].absolute():
        raise RuntimeError("Run `blog` from the root folder: `./blog`")
    parsed_args = parse_args(sys.argv[1:])
    command_func = eval(f"command_{parsed_args.command}")
    return command_func(parsed_args)

if __name__ == "__main__":
    main(sys.argv[1:])
