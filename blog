#!/usr/bin/env python

## Imports

import os
import io
import re
import sys
import glob
import json
import shutil
import secrets
import threading
import subprocess
import http.server
import socketserver
from pathlib import Path
from datetime import datetime, timedelta
from functools import partial, lru_cache
from typing import Dict, Tuple, List, Callable
from argparse import ArgumentParser, Namespace

from jinja2 import Template, Environment, FileSystemLoader


## Constants

HTMLDIR: Path = Path("html")
TAGDIR: Path = Path("tags")
POSTDIR: Path = Path("posts")
STATICDIR: Path = Path("static")
TEMPLATEDIR: Path = Path("templates")
COMMANDS: Tuple[str, ...] = ("build", "clean", "init", "serve", "publish")
EXTS: Dict[str, str] = {
    ".md": "MarkdownPost",
    ".ipynb": "NotebookPost",
    ".html": "HtmlPost",
}

## Decorators
cache = partial(lru_cache, None, True)

## Functions

def symbolic_link(src: Path, dest: Path):
    subprocess.check_output(["ln", "-srf", src, dest])

def copy_folder(src: Path, dest: Path):
    shutil.rmtree(dest/src, ignore_errors=True)
    shutil.copytree(src, dest/src, symlinks=False, ignore_dangling_symlinks=True)

def get_template(name: str) -> Template:
    path = TEMPLATEDIR/name
    if not os.path.exists(path):
        return Template("")
    with open(path, "r") as file:
        content = file.read()
    template = Environment(loader=FileSystemLoader(TEMPLATEDIR)).from_string(content)
    return template

def replace_markdown_links(content: str) -> str:
    # TODO: do this more robustly:
    parts = content.split("](")
    for i, part in enumerate(parts[1:], start=1):
        smallparts = part.split(")")
        if smallparts[0].startswith("http://") or smallparts[0].startswith("https://") or smallparts[0].startswith("static"):
            continue
        smallparts[0] = f"/{Path(smallparts[0]).stem}.html"
        parts[i] = ")".join(smallparts)
    content = "](".join(parts)
    return content

def md2html(content: str) -> str:
    content = replace_markdown_links(content)
    mdout = subprocess.Popen(["printf", content], stdout=subprocess.PIPE).stdout
    html = subprocess.check_output(['pandoc'], stdin=mdout).decode().strip()
    return html

def ipynb2html(content: str) -> str:
    from nbconvert.nbconvertapp import NbConvertApp # type: ignore
    from nbconvert.exporters.html import HTMLExporter # type: ignore
    content = replace_markdown_links(content)
    app = NbConvertApp.instance()
    app.initialize(["--template=basic"])
    app.exporter = HTMLExporter(config=app.config)
    html, _ = app.export_single_notebook(
        notebook_filename=None,
        resources=None,
        input_buffer=io.StringIO(content)
    )
    return html


## Classes

class Post:
    _posts: Dict[Path, 'Post'] = {}
    _template = get_template("post.html")
    def __new__(cls, path: Path):
        if path in cls._posts:
            return cls._posts[path]
        return super().__new__(cls)
    def __init__(self, path: Path):
        if path in self._posts:
            return
        self.path = Path(path)
        self.tags: List[Tag] = []
        self._posts[path] = self
        self.lines = self.readlines()
    def render(self, **kwargs):
        html = self._template.render(page=self, **kwargs)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    def readlines(self) -> List[str]:
        with open(self.path, "r") as file:
            lines = file.read().split("\n")
        return lines
    @cache()
    def author(self) -> str:
        author = subprocess.check_output(['git', 'log', '--pretty=format:%an%x09', self.path]).decode().split("\n")[0].strip()
        if not author:
            author = "Anonymous"
        return author.lower().capitalize()
    @cache()
    def content(self) -> str:
        return md2html("\n".join(self.lines[1:]))
    @cache()
    def name(self) -> str:
        return str(self.path.relative_to(POSTDIR).stem)
    @cache()
    def uri(self) -> str:
        return f"{self.name()}.html"
    @cache()
    def utcpublished(self) -> datetime:
        try:
            datetimestr = subprocess.check_output(['git', 'log', '--diff-filter=A', '--follow', '--format=%aD', '--max-count=1', '--', self.path]).decode().strip()
            localdatetime = datetime.strptime(datetimestr, "%a, %d %b %Y %H:%M:%S %z")
            assert localdatetime.tzinfo is not None
            utcoffset = localdatetime.tzinfo.utcoffset(localdatetime)
            assert utcoffset is not None
            return datetime.strptime((localdatetime-utcoffset).strftime("%Y%b%d%H%M%S"), "%Y%b%d%H%M%S")
        except ValueError:
            return datetime.utcnow()
    @cache()
    def utcmodified(self) -> datetime:
        try:
            datetimestr = subprocess.check_output(["git", "log", "-1", '--format=%aD', "--", self.path]).decode().strip()
            localdatetime = datetime.strptime(datetimestr, "%a, %d %b %Y %H:%M:%S %z")
            assert localdatetime.tzinfo is not None
            utcoffset = localdatetime.tzinfo.utcoffset(localdatetime)
            assert utcoffset is not None
            return datetime.strptime((localdatetime-utcoffset).strftime("%Y%b%d%H%M%S"), "%Y%b%d%H%M%S")
        except ValueError:
            return datetime.utcnow()
    @cache()
    def summary(self) -> str:
        lines = []
        for line in self.lines[1:]:
            line = line.strip()
            if not line:
                break
            lines.append(line)
        html = md2html("\n".join(lines))
        return html
    @cache()
    def textsummary(self) -> str:
        summary = self.summary()
        return re.sub("<.*?>", "", summary)
    @cache()
    def title(self) -> str:
        title = re.sub("^[ ]*[#]*[ ]*", "", self.lines[0])
        return title

class NotebookPost(Post):
    def __init__(self, path: Path):
        super().__init__(path)
        self.json = self.readjson()
        self._replace_raw_cell_by_markdown_cell(self.json)
        self.plotly_plots, self.vega_plots = self._patch_json_for_interactive_plots(self.json)
        self.lines = self.readlines()
    @staticmethod
    def _patch_json_for_interactive_plots(dic: Dict) -> Dict[str, str]:
        vega = ('<div id="vis{id}"></div>\n'
                '<script type="text/javascript">\n'
                'var spec = {spec}\n'
                'vegaEmbed("#vis{id}", spec, {{"actions":false}});\n'
                '</script>')
        plotly = ('<div id="{id}" class="plotly-graph-div"></div>\n'
                  '<script type="text/javascript">\n'
                  'window.PLOTLYENV=window.PLOTLYENV || {{}}\n'
                  'window.PLOTLYENV.BASE_URL="https://plot.ly"\n'
                  'var spec = {spec}\n'
                  'Plotly.newPlot("{id}", spec, {{}}, {{"showLink": false, "linkText": ""}})\n'
                  '\n</script>\n')
        vega_plots = {}
        plotly_plots = {}
        for i, cell in enumerate(dic['cells']):
            outputs = cell.get('outputs')
            if not outputs:
                continue
            for output in outputs:
                data = output.get('data')
                if not data:
                    continue
                keys = [k for k in data if ('plotly' in k or 'vega' in k)]
                if not keys:
                    continue
                del data['image/png']
                data['text/plain'] = ''
                for key in keys:
                    id = secrets.token_hex(8)
                    data['text/plain'] = data['text/plain'] + "{{ %s }}\n"%id
                    if 'vega' in key:
                        vega_plots['{{ %s }}'%id] = vega.format(id=id, spec=json.dumps(data[key]))
                    elif 'plotly' in key:
                        plotly_plots['{{ %s }}'%id] = plotly.format(id=id, spec=json.dumps(data[key]))
        return plotly_plots, vega_plots
    def readjson(self) -> Dict:
        with open(self.path, "r") as file:
            dic = json.load(file)
        return dic
    @staticmethod
    def _replace_raw_cell_by_markdown_cell(dic: Dict):
        for cell in dic['cells']:
            if cell['cell_type'] == 'raw':
                cell['cell_type'] = 'markdown'
                cell['source'] = ['\n```python\n',*cell['source'],'\n```\n']
    def _patch_html_for_plotly(self, html: str) -> str:
        # update html with saved key value pairs
        for k, v in self.plotly_plots.items():
            html = html.replace(k,v)
        # patch plotly plot (i know... quite terrible hack)
        idx = html.find(r'require(["plotly"], function(Plotly) {')
        while idx > 0:
            html = html.replace(r'require(["plotly"], function(Plotly) {', '', 1)
            idx1 = html.find(r'.then(function()', idx)
            idx2 = html.find(r'</script>', idx1)
            html = html[:idx1] + r"};" + html[idx2:]
            idx = html.find(r'require(["plotly"], function(Plotly) {', idx2)
        html = html.replace('"paper_bgcolor": "white"', '"paper_bgcolor": "#00000000"')
        html = re.sub('"font": {"color": "#......"}', '"font": {"color": "#999999"}', html)
        return html
    def _patch_html_for_vega(self, html: str) -> str:
        # update html with saved key value pairs
        for k, v in self.vega_plots.items():
            html = html.replace(k,v)
        html = html.replace('"mode": "vega-lite"', '"mode": "vega-lite", "actions": false')
        html = re.sub('"view": {([^}]*)}', r'"view": {\1}, "background": "#00000000"', html)
        return html
    def _patch_js_license_in_html(self, html: str) -> str:
        lines = html.split("\n")
        for i, line in enumerate(lines):
            if not "<script" in line:
                continue
            if "PlotlyConfig" in lines[i+1]:
                lines[i+1] = f"// @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&dn=expat.txt Expat\n{lines[i+1]}"
                for j, line in enumerate(lines[i:]):
                    if "</script>" in line:
                        break
                lines[i+j] = "// @license-end\n</script>"
            if "vega.github.io" in lines[i+1]:
                lines[i+1] = f"// @license magnet:?xt=urn:btih:c80d50af7d3db9be66a4d0a86db0286e4fd33292&dn=bsd-3-clause.txt BSD-3-Clause\n{lines[i+1]}"
                for j, line in enumerate(lines[i:]):
                    if "</script>" in line:
                        break
                lines[i+j] = lines[i+j].replace("</script>", "// @license-end\n</script>")
            if "plotly-graph-div" in lines[i-1]:
                lines[i+1] = f"// @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&dn=expat.txt Expat\n{lines[i+1]}"
                for j, line in enumerate(lines[i:]):
                    if "</script>" in line:
                        break
                lines[i+j] = lines[i+j].replace("</script>", "\n// @license-end\n</script>")

        html = "\n".join(lines)
        return html
    def readlines(self) -> List[str]:
        if not hasattr(self, "json"):
            return []
        with open(self.path, "r") as file:
            lines = self.json["cells"][0]["source"]
        # remove title.
        while not lines[0].strip():
            lines = lines[1:]
        title = lines[0]
        while title[0] == " ":
            title = title[1:]
        if not title.startswith("# "):
            raise RuntimeError(f"could not find title for post '{self.name()}'")
        self.json["cells"][0]["source"] = lines[1:]
        return "".join(lines).split("\n")
    @cache()
    def content(self) -> str:
        return ipynb2html(json.dumps(self.json))
    def render(self, **kwargs):
        html = self._template.render(page=self, vega=bool(self.vega_plots), plotly=bool(self.plotly_plots), **kwargs)
        html = self._patch_html_for_plotly(html)
        html = self._patch_html_for_vega(html)
        html = self._patch_js_license_in_html(html)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)

class MarkdownPost(NotebookPost):
    def readjson(self) -> Dict:
        with open(self.path, "r") as file:
            lines = file.readlines()
        dic = {
            "cells": [
                {
                   "cell_type": "markdown",
                   "metadata": {},
                    "source" : lines,
                }
            ],
             "metadata": {},
             "nbformat": 4,
             "nbformat_minor": 4
        }
        return dic

class HtmlPost(Post):
    def render(self, **kwargs):
        html = self._template.render(page=self, **kwargs)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    def readlines(self) -> List[str]:
        with open(self.path, "r") as file:
            lines = file.read().split("\n")
        return lines
    @cache()
    def author(self) -> str:
        author = subprocess.check_output(['git', 'log', '--pretty=format:%an%x09', self.path]).decode().split("\n")[0].strip()
        if not author:
            author = "Anonymous"
        return author.lower().capitalize()
    @cache()
    def content(self) -> str:
        return "\n".join(self.lines[1:])
    @cache()
    def title(self) -> str:
        return self.lines[0].split("<h1>")[1].split("</h1>")[0]


class Tag:
    _tags: Dict[Path, 'Tag'] = {}
    _template = get_template("tag.html")
    def __new__(cls, path: Path):
        if path in cls._tags:
            return cls._tags[path]
        return super().__new__(cls)
    def __init__(self, path: Path):
        if path in self._tags:
            return
        self.path = Path(path)
        self.posts: List[Post] = []
        self._tags[path] = self
        for post_path in self.path.glob("*"):
            post_path = post_path.resolve().relative_to(Path(".").resolve())
            if post_path.is_dir():
                continue
            clsname = EXTS.get(post_path.suffix, None)
            if clsname is None:
                continue
            cls = eval(clsname)
            post: Post = cls(post_path)
            self.posts.append(post)
            post.tags.append(self)
        post.tags = sorted(post.tags, key=lambda x: (-x.num_posts(), x.name()))
        self.posts = sorted(self.posts, key=lambda x: x.utcpublished(), reverse=True)
    def render(self, **kwargs):
        html = self._template.render(page=self, **kwargs)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    @cache()
    def num_posts(self) -> int:
        return int(len(self.posts))
    @cache()
    def name(self) -> str:
        return str(self.path.relative_to(TAGDIR).stem.split("(")[0].strip())
    @cache()
    def longname(self) -> str:
        stem = self.path.relative_to(TAGDIR).stem
        if not "(" in stem:
            return self.name()
        return str(stem.split("(")[1].split(")")[0].strip())
    @cache()
    def uri(self) -> str:
        return str(TAGDIR/f"{self.name()}.html")
    @cache()
    def title(self) -> str:
        name = self.name()
        longname = self.longname()
        if name == longname:
            return name.capitalize()
        return f"{longname.capitalize()} [{name.upper()}]"

class Index:
    _template = get_template("index.html")
    _xmltemplate = get_template("index.xml")
    def __init__(self):
        self.posts, self.tags = [], []
        for post_path in POSTDIR.glob("*"):
            if post_path.is_dir():
                continue
            clsname = EXTS.get(post_path.suffix, None)
            if clsname is None:
                continue
            cls = eval(clsname)
            post: Post = cls(post_path)
            self.posts.append(post)
        for tag_path in TAGDIR.glob("*"):
            if not tag_path.is_dir():
                continue
            self.tags.append(Tag(tag_path))
        self.tags = sorted(self.tags, key=lambda x: (-x.num_posts(), x.name()))
        self.posts = sorted(self.posts, key=lambda x: x.utcpublished(), reverse=True)
    def render(self, **kwargs):
        html = self._template.render(page=self, newest_post=self.posts[0], tags=self.tags, **kwargs)
        xml = self._xmltemplate.render(page=self, date=datetime.utcnow(), **kwargs)
        num_posts = len(self.posts)
        print("\nposts:\n------")
        for i, post in enumerate(self.posts):
            next_post = None if i==0 else self.posts[i-1]
            previous_post = None if i == num_posts-1 else self.posts[i+1]
            print(post.name())
            post.render(next_post=next_post, previous_post=previous_post, tags=self.tags)
        print("\ntags:\n-----")
        for tag in self.tags:
            print(tag.name())
            tag.render(tags=self.tags)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
        with open(f"{HTMLDIR/self.uri()[:-5]}.xml", "w") as file:
            print(xml, file=file)
    @cache()
    def num_posts(self) -> int:
        return int(len(self.posts))
    @cache()
    def name(self) -> str:
        return "index"
    @cache()
    def title(self) -> str:
        return ""
    @cache()
    def uri(self) -> str:
        return f"{self.name()}.html"


## Argument parsers

def parse_args(args: List[str]) -> Namespace:
    main_args = parse_command(args[:1])
    parse_flags = eval(f"parse_{main_args.command}")
    sub_args = parse_flags(args[1:])
    parsed_args = Namespace(**main_args.__dict__, **sub_args.__dict__)
    parsed_args.orig_args = args
    return parsed_args

def parse_build(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog-build: build the blog.")
    parsed_args = parser.parse_args(args)
    return parsed_args

def parse_clean(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog-clean: remove the exported html.")
    parsed_args = parser.parse_args(args)
    return parsed_args

def parse_command(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog: a static blog generator.")
    parser.add_argument("command", choices=COMMANDS, help="command to execute")
    parsed_args = parser.parse_args(args)
    return parsed_args

def parse_init(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog-init: initialize the blog.")
    parsed_args = parser.parse_args(args)
    return parsed_args

def parse_publish(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog-publish: publish the blog.")
    parser.add_argument("destination", help="destination to rsync to in the form user@host:/path/to/folder")
    parsed_args = parser.parse_args(args)
    return parsed_args

def parse_serve(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog-serve: serve your static blog locally")
    parser.add_argument("-p", "--port", default=8787, type=int, help="(default: 8787) port to locally serve the development website")
    parser.add_argument("-b", "--no-fork", action="store_true", default=False, help="prevent forking of the server")
    parsed_args = parser.parse_args(args)
    return parsed_args


## Commands

def command_build(args: Namespace):
    command_init(args)
    index = Index()
    index.render()

def command_clean(args: Namespace):
    for directory in (HTMLDIR, HTMLDIR/TAGDIR):
        shutil.rmtree(directory, ignore_errors=True)
    command_init(args)

def command_init(args: Namespace):
    for directory in (HTMLDIR, TAGDIR, POSTDIR, STATICDIR, TEMPLATEDIR, HTMLDIR/TAGDIR):
        os.makedirs(directory, exist_ok=True)
    # symbolic_link(STATICDIR, HTMLDIR)
    copy_folder(STATICDIR, HTMLDIR)
    symbolic_link(STATICDIR, POSTDIR)

def command_publish(args: Namespace):
    destination = args.destination
    if not destination.endswith("/"):
        destination = destination + "/"
    exit_code = subprocess.call(["rsync", "-avP", "--delete", "./", args.destination])
    if exit_code:
        raise subprocess.CalledProcessError(f"rsync exited with exit code {exit_code}")
    print("\nblog published.")

def command_serve(args: Namespace):
    if not args.no_fork:
        newargs = ["python", __file__, *args.orig_args, "--no-fork"]
        with open(os.devnull, "w") as file:
            process = subprocess.Popen(newargs, stdout=file, stderr=file)
        print(f"serving at port {args.port} with pid {process.pid}")
        return
    print(f"serving at port {args.port}")
    os.chdir(HTMLDIR)
    httpd = socketserver.TCPServer(("", args.port), http.server.SimpleHTTPRequestHandler)
    httpd.serve_forever()

## Main

def main(args: List[str]):
    if Path(".").absolute() != Path(__file__).parents[0].absolute():
        raise RuntimeError("Run `blog` from the root folder: `./blog`")
    parsed_args = parse_args(sys.argv[1:])
    command = eval(f"command_{parsed_args.command}")
    return command(parsed_args)

if __name__ == "__main__":
    main(sys.argv[1:])
