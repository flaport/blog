#!/usr/bin/env python

## Imports

import os
import io
import re
import sys
import glob
import json
import shutil
import secrets
import subprocess
from pathlib import Path
from datetime import datetime, timedelta
from functools import partial, lru_cache
from typing import Dict, Tuple, List, Callable
from argparse import ArgumentParser, Namespace

from jinja2 import Template, Environment, FileSystemLoader


## Constants

HTMLDIR: Path = Path("html")
TAGDIR: Path = Path("tags")
POSTDIR: Path = Path("posts")
STATICDIR: Path = Path("static")
TEMPLATEDIR: Path = Path("templates")
COMMANDS: Tuple[str, ...] = ("build", "clean", "init")
EXTS: Dict[str, str] = {
    ".md": "MarkdownPost",
    ".ipynb": "NotebookPost",
}

## Decorators
cache = partial(lru_cache, None, True)

## Functions

def symbolic_link(src: Path, dest: Path):
    subprocess.check_output(["ln", "-srf", src, dest])

def get_template(name: str) -> Template:
    path = TEMPLATEDIR/name
    if not os.path.exists(path):
        return Template("")
    with open(path, "r") as file:
        content = file.read()
    template = Environment(loader=FileSystemLoader(TEMPLATEDIR)).from_string(content)
    return template

def replace_markdown_links(content: str) -> str:
    # TODO: do this more robustly:
    parts = content.split("](")
    for i, part in enumerate(parts[1:], start=1):
        smallparts = part.split(")")
        if smallparts[0].startswith("http://") or smallparts[0].startswith("https://") or smallparts[0].startswith("static"):
            continue
        smallparts[0] = f"/{Path(smallparts[0]).stem}.html"
        parts[i] = ")".join(smallparts)
    content = "](".join(parts)
    return content

def md2html(content: str) -> str:
    content = replace_markdown_links(content)
    mdout = subprocess.Popen(["printf", content], stdout=subprocess.PIPE).stdout
    html = subprocess.check_output(['pandoc'], stdin=mdout).decode().strip()
    return html

def ipynb2html(content: str) -> str:
    from nbconvert.nbconvertapp import NbConvertApp # type: ignore
    from nbconvert.exporters.html import HTMLExporter # type: ignore
    content = replace_markdown_links(content)
    app = NbConvertApp.instance()
    app.initialize(["--template=basic"])
    app.exporter = HTMLExporter(config=app.config)
    html, _ = app.export_single_notebook(
        notebook_filename=None,
        resources=None,
        input_buffer=io.StringIO(content)
    )
    return html


## Classes

class Post:
    _posts: Dict[Path, 'Post'] = {}
    _template = get_template("post.html")
    def __new__(cls, path: Path):
        if path in cls._posts:
            return cls._posts[path]
        return super().__new__(cls)
    def __init__(self, path: Path):
        if path in self._posts:
            return
        self.path = Path(path)
        self.tags: List[Tag] = []
        self._posts[path] = self
        self.lines = self.readlines()
    def render(self):
        html = self._template.render(page=self)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    def readlines(self) -> List[str]:
        with open(self.path, "r") as file:
            lines = file.read().split("\n")
        return lines
    @cache()
    def author(self) -> str:
        author = subprocess.check_output(['git', 'log', '--pretty=format:%an%x09', self.path]).decode().split("\n")[0].strip()
        if not author:
            author = "Anonymous"
        return author.lower().capitalize()
    @cache()
    def content(self) -> str:
        return md2html("\n".join(self.lines[1:]))
    @cache()
    def name(self) -> str:
        return str(self.path.relative_to(POSTDIR).stem)
    @cache()
    def uri(self) -> str:
        return f"{self.name()}.html"
    @cache()
    def utcpublished(self) -> datetime:
        datetimestr = subprocess.check_output(['git', 'log', '--diff-filter=A', '--follow', '--format=%aD', '--max-count=1', '--', self.path]).decode().strip()
        localdatetime = datetime.strptime(datetimestr, "%a, %d %b %Y %H:%M:%S %z")
        assert localdatetime.tzinfo is not None
        utcoffset = localdatetime.tzinfo.utcoffset(localdatetime)
        assert utcoffset is not None
        return datetime.strptime((localdatetime-utcoffset).strftime("%Y%b%d%H%M%S"), "%Y%b%d%H%M%S")
    @cache()
    def utcmodified(self) -> datetime:
        datetimestr = subprocess.check_output(["git", "log", "-1", '--format=%aD', "--", self.path]).decode().strip()
        localdatetime = datetime.strptime(datetimestr, "%a, %d %b %Y %H:%M:%S %z")
        assert localdatetime.tzinfo is not None
        utcoffset = localdatetime.tzinfo.utcoffset(localdatetime)
        assert utcoffset is not None
        return datetime.strptime((localdatetime-utcoffset).strftime("%Y%b%d%H%M%S"), "%Y%b%d%H%M%S")
    @cache()
    def summary(self) -> str:
        lines = []
        for line in self.lines[1:]:
            line = line.strip()
            if not line:
                break
            lines.append(line)
        html = md2html("\n".join(lines))
        return html
    @cache()
    def title(self) -> str:
        title = re.sub("^[ ]*[#]*[ ]*", "", self.lines[0])
        return title

class NotebookPost(Post):
    def __init__(self, path: Path):
        super().__init__(path)
        self.json = self.readjson()
        self._replace_raw_cell_by_markdown_cell(self.json)
        self.interactive_plots = self._patch_json_for_plotly(self.json)
        self.lines = self.readlines()
    def readjson(self) -> Dict:
        with open(self.path, "r") as file:
            dic = json.load(file)
        return dic
    @staticmethod
    def _replace_raw_cell_by_markdown_cell(dic: Dict):
        for cell in dic['cells']:
            if cell['cell_type'] == 'raw':
                cell['cell_type'] = 'markdown'
                cell['source'] = ['\n```\n',*cell['source'],'\n```\n']
    @staticmethod
    def _patch_json_for_plotly(dic: Dict) -> Dict[str, str]:
        template = ('<div id="{id}" class="plotly-graph-div"></div>\n'
                    '<script type="text/javascript">\n'
                    'window.PLOTLYENV=window.PLOTLYENV || {{}}\n'
                    'window.PLOTLYENV.BASE_URL="https://plot.ly"\n'
                    'var spec = {spec}\n'
                    'Plotly.newPlot("{id}", spec, {{}}, {{"showLink": false, "linkText": ""}})</script>\n')
        interactive_plots = {}
        for i, cell in enumerate(dic['cells']):
            outputs = cell.get('outputs')
            if not outputs:
                continue
            for output in outputs:
                data = output.get('data')
                if not data:
                    continue
                keys = [k for k in data if 'plotly' in k]
                if not keys:
                    continue
                data['text/plain'] = ''
                for key in keys:
                    id = secrets.token_hex(8)
                    data['text/plain'] = data['text/plain'] + "{{ %s }}\n"%id
                    interactive_plots['{{ %s }}'%id] = template.format(id=id, spec=json.dumps(data[key]))
        return interactive_plots
    @staticmethod
    def _patch_html_for_plotly(html: str, plots: Dict[str, str]) -> str:
        # update html with saved key value pairs
        for k, v in plots.items():
            html = html.replace(k,v)
        # patch plotly plot (i know... quite terrible hack)
        idx = html.find(r'require(["plotly"], function(Plotly) {')
        while idx > 0:
            html = html.replace(r'require(["plotly"], function(Plotly) {', '', 1)
            idx1 = html.find(r'.then(function()', idx)
            idx2 = html.find(r'</script>', idx1)
            html = html[:idx1] + r"};" + html[idx2:]
            idx = html.find(r'require(["plotly"], function(Plotly) {', idx2)
        html = html.replace('"paper_bgcolor": "white"', '"paper_bgcolor": "#00000000"')
        html = re.sub('"font": {"color": "#......"}', '"font": {"color": "#999999"}', html)
        return html
    @staticmethod
    def _patch_html_for_vega(html: str) -> str:
        html = html.replace('"mode": "vega-lite"', '"mode": "vega-lite", "actions": false')
        html = re.sub('"view": {([^}]*)}', r'"view": {\1}, "background": "#00000000"', html)
        return html

    def readlines(self) -> List[str]:
        if not hasattr(self, "json"):
            return []
        with open(self.path, "r") as file:
            lines = self.json["cells"][0]["source"]
        # remove title.
        while not lines[0].strip():
            lines = lines[1:]
        title = lines[0]
        while title[0] == " ":
            title = title[1:]
        if not title.startswith("# "):
            raise RuntimeError(f"could not find title for post '{self.name()}'")
        self.json["cells"][0]["source"] = lines[1:]
        return "".join(lines).split("\n")
    @cache()
    def content(self) -> str:
        return ipynb2html(json.dumps(self.json))
    def render(self):
        html = self._template.render(page=self)
        html = self._patch_html_for_plotly(html, self.interactive_plots)
        html = self._patch_html_for_vega(html)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)

class MarkdownPost(NotebookPost):
    def readjson(self) -> Dict:
        with open(self.path, "r") as file:
            lines = file.readlines()
        dic = {
            "cells": [
                {
                   "cell_type": "markdown",
                   "metadata": {},
                    "source" : lines,
                }
            ],
             "metadata": {},
             "nbformat": 4,
             "nbformat_minor": 4
        }
        return dic


class Tag:
    _tags: Dict[Path, 'Tag'] = {}
    _template = get_template("tag.html")
    def __new__(cls, path: Path):
        if path in cls._tags:
            return cls._tags[path]
        return super().__new__(cls)
    def __init__(self, path: Path):
        if path in self._tags:
            return
        self.path = Path(path)
        self.posts: List[Post] = []
        self._tags[path] = self
        for post_path in self.path.glob("*"):
            post_path = post_path.resolve().relative_to(Path(".").resolve())
            if post_path.is_dir():
                continue
            clsname = EXTS.get(post_path.suffix, None)
            if clsname is None:
                continue
            cls = eval(clsname)
            post: Post = cls(post_path)
            self.posts.append(post)
            post.tags.append(self)
        post.tags = sorted(post.tags, key=lambda x: x.name())
        self.posts = sorted(self.posts, key=lambda x: x.utcpublished(), reverse=True)
    def render(self):
        html = self._template.render(page=self)
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    @cache()
    def name(self) -> str:
        return str(self.path.relative_to(TAGDIR).stem)
    @cache()
    def uri(self) -> str:
        return str(TAGDIR/f"{self.name()}.html")
    @cache()
    def title(self) -> str:
        return self.name().capitalize()

class Index:
    _template = get_template("index.html")
    def __init__(self):
        self.posts, self.tags = [], []
        for post_path in POSTDIR.glob("*"):
            if post_path.is_dir():
                continue
            clsname = EXTS.get(post_path.suffix, None)
            if clsname is None:
                continue
            cls = eval(clsname)
            post: Post = cls(post_path)
            self.posts.append(post)
        for tag_path in TAGDIR.glob("*"):
            if not tag_path.is_dir():
                continue
            self.tags.append(Tag(tag_path))
        self.tags = sorted(self.tags, key=lambda x: x.name())
        self.posts = sorted(self.posts, key=lambda x: x.utcpublished(), reverse=True)
    def render(self):
        html = self._template.render(page=self)
        for post in self.posts:
            print(post.name())
            post.render()
        for tag in self.tags:
            print(tag.name())
            tag.render()
        with open(HTMLDIR/self.uri(), "w") as file:
            print(html, file=file)
    @cache()
    def name(self) -> str:
        return "index"
    @cache()
    def title(self) -> str:
        return self.name().capitalize()
    @cache()
    def uri(self) -> str:
        return f"{self.name()}.html"


## Argument parser

def parse_args(args: List[str]) -> Namespace:
    parser = ArgumentParser(description="blog: a static blog generator.")
    parser.add_argument("command", choices=COMMANDS, help="subcommand to execute")
    parsed_args = parser.parse_args(args)
    return parsed_args


## Commands

def command_build(args: Namespace):
    command_init(args)
    index = Index()
    index.render()

def command_clean(args: Namespace):
    for directory in (HTMLDIR, HTMLDIR/TAGDIR):
        shutil.rmtree(directory, ignore_errors=True)
    command_init(args)

def command_init(args: Namespace):
    for directory in (HTMLDIR, TAGDIR, POSTDIR, STATICDIR, TEMPLATEDIR, HTMLDIR/TAGDIR):
        os.makedirs(directory, exist_ok=True)
    symbolic_link(STATICDIR, HTMLDIR)
    symbolic_link(STATICDIR, POSTDIR)

## Main

def main(args: List[str]):
    if Path(".").absolute() != Path(__file__).parents[0].absolute():
        raise RuntimeError("Run `blog` from the root folder: `./blog`")
    parsed_args = parse_args(sys.argv[1:])
    command_func = eval(f"command_{parsed_args.command}")
    return command_func(parsed_args)

if __name__ == "__main__":
    main(sys.argv[1:])
